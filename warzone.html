<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Customizable Image Battle Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Roboto Mono', monospace;
        background-color: #111827;
        color: #f3f4f6;
      }
      canvas {
        background-color: #1f2937;
        border: 2px solid #4b5563;
        border-radius: 0.5rem;
        cursor: default;
      }
      .stat-display {
        background-color: #1f2937;
        border: 1px solid #374151;
        border-radius: 0.5rem;
        padding: 0.75rem 1rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
      }
      .sim-button {
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
      }
      .sim-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.5);
      }
      .sim-button:active {
        transform: translateY(0);
      }
      .sim-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #winner-overlay {
        background-color: rgba(17, 24, 39, 0.9);
        transition: opacity 0.5s ease;
      }
      .upload-label {
        background-color: #374151;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .upload-label:hover {
        background-color: #4b5563;
      }
      input[type='file'] {
        display: none;
      }
    </style>
  </head>
  <body class="flex flex-col items-center justify-center min-h-screen p-4">
    <h1 class="text-4xl font-bold text-white mb-2">Ecosystem Battle</h1>
    <p class="text-gray-400 mb-6">
      Upload your own images for the creatures and arena!
    </p>

    <div class="w-full max-w-4xl">
      <!-- Stat Displays -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div class="stat-display text-center">
          <h2 class="text-xl font-bold text-cyan-400">Guardian</h2>
          <p
            id="guardian-stats"
            class="text-sm text-gray-300 whitespace-nowrap"
          ></p>
        </div>
        <div class="stat-display text-center">
          <h2 class="text-xl font-bold text-red-400">Striker</h2>
          <p
            id="striker-stats"
            class="text-sm text-gray-300 whitespace-nowrap"
          ></p>
        </div>
      </div>

      <!-- Canvas and Winner Overlay -->
      <div class="relative flex justify-center">
        <canvas id="simulationCanvas"></canvas>
        <div
          id="winner-overlay"
          class="absolute inset-0 flex flex-col items-center justify-center hidden opacity-0"
        >
          <h2 id="winner-text" class="text-5xl font-bold"></h2>
          <p class="text-gray-300 mt-2">The simulation has ended.</p>
        </div>
      </div>

      <!-- Controls -->
      <div class="flex justify-center mt-4">
        <button
          id="start-reset-btn"
          class="sim-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg"
        >
          Loading...
        </button>
      </div>

      <!-- Image Uploads -->
      <div class="mt-6 p-4 rounded-lg bg-gray-800 border border-gray-700">
        <h3 class="text-lg font-bold text-center mb-4">Customize Simulation</h3>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
          <div>
            <h4 class="font-bold mb-2">Guardian (Creature 1)</h4>
            <label class="upload-label" for="g-body-upload">Body Image</label>
            <input type="file" id="g-body-upload" accept="image/*" />
            <label class="upload-label mt-2" for="g-weapon-upload"
              >Weapon Image</label
            >
            <input type="file" id="g-weapon-upload" accept="image/*" />
          </div>
          <div>
            <h4 class="font-bold mb-2">Striker (Creature 2)</h4>
            <label class="upload-label" for="s-body-upload">Body Image</label>
            <input type="file" id="s-body-upload" accept="image/*" />
            <label class="upload-label mt-2" for="s-weapon-upload"
              >Weapon Image</label
            >
            <input type="file" id="s-weapon-upload" accept="image/*" />
          </div>
          <div>
            <h4 class="font-bold mb-2">Arena</h4>
            <label class="upload-label" for="bg-upload">Background Image</label>
            <input type="file" id="bg-upload" accept="image/*" />
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('simulationCanvas');
      const ctx = canvas.getContext('2d');

      // UI Elements
      const guardianStatsEl = document.getElementById('guardian-stats');
      const strikerStatsEl = document.getElementById('striker-stats');
      const startResetBtn = document.getElementById('start-reset-btn');
      const winnerOverlay = document.getElementById('winner-overlay');
      const winnerText = document.getElementById('winner-text');

      // Image Upload Inputs
      const gBodyUpload = document.getElementById('g-body-upload');
      const gWeaponUpload = document.getElementById('g-weapon-upload');
      const sBodyUpload = document.getElementById('s-body-upload');
      const sWeaponUpload = document.getElementById('s-weapon-upload');
      const bgUpload = document.getElementById('bg-upload');

      let creatures = [];
      let particles = [];
      let animationFrameId;
      let isRunning = false;

      // Image Objects
      let guardianBodyImg = new Image();
      let guardianWeaponImg = new Image();
      let strikerBodyImg = new Image();
      let strikerWeaponImg = new Image();
      let backgroundImg = new Image();

      // --- Image Loading ---
      const defaultImages = {
        gBody: 'https://placehold.co/100x100/22d3ee/FFFFFF?text=G',
        gWeapon: 'https://placehold.co/200x20/22d3ee/FFFFFF?text=Sword',
        sBody: 'https://placehold.co/80x80/f87171/FFFFFF?text=S',
        sWeapon: 'https://placehold.co/150x20/f87171/FFFFFF?text=Dagger',
        bg: 'https://placehold.co/500x500/1f2937/4b5563?text=Arena',
      };

      function loadImage(src, imageObject) {
        return new Promise((resolve, reject) => {
          imageObject.onload = () => resolve(imageObject);
          imageObject.onerror = reject;
          imageObject.src = src;
        });
      }

      function handleFileUpload(event, imageObject) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            loadImage(e.target.result, imageObject).then(redrawStatic);
          };
          reader.readAsDataURL(file);
        }
      }

      gBodyUpload.addEventListener('change', (e) =>
        handleFileUpload(e, guardianBodyImg)
      );
      gWeaponUpload.addEventListener('change', (e) =>
        handleFileUpload(e, guardianWeaponImg)
      );
      sBodyUpload.addEventListener('change', (e) =>
        handleFileUpload(e, strikerBodyImg)
      );
      sWeaponUpload.addEventListener('change', (e) =>
        handleFileUpload(e, strikerWeaponImg)
      );
      bgUpload.addEventListener('change', (e) =>
        handleFileUpload(e, backgroundImg)
      );

      // --- Creature Class ---
      class Creature {
        constructor(
          x,
          y,
          radius,
          color,
          name,
          maxHealth,
          speed,
          damage,
          weapon,
          images
        ) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * speed;
          this.vy = (Math.random() - 0.5) * speed;
          this.radius = radius;
          this.color = color;
          this.name = name;
          this.maxHealth = maxHealth;
          this.health = maxHealth;
          this.speed = speed;
          this.damage = damage;
          this.mass = Math.PI * radius * radius;
          this.weapon = { ...weapon, image: images.weapon };
          this.bodyImage = images.body;
          this.lastHitTime = 0;
        }

        draw() {
          // Draw Weapon
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.weapon.angle);
          // Draw image centered on its height
          ctx.drawImage(
            this.weapon.image,
            0,
            -this.weapon.width / 2,
            this.weapon.length,
            this.weapon.width
          );
          ctx.restore();

          // Draw Body
          ctx.drawImage(
            this.bodyImage,
            this.x - this.radius,
            this.y - this.radius,
            this.radius * 2,
            this.radius * 2
          );

          // Draw Health Bar
          const barWidth = this.radius * 1.5;
          const barHeight = 7;
          const barY = this.y - this.radius - 15;
          const healthPercentage = this.health / this.maxHealth;

          ctx.fillStyle = 'white';
          ctx.font = '10px Roboto Mono';
          ctx.textAlign = 'center';
          ctx.fillText(
            `${Math.ceil(this.health)}/${this.maxHealth}`,
            this.x,
            barY - 2
          );
          ctx.fillStyle = '#4b5563';
          ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
          ctx.fillStyle = this.color;
          ctx.fillRect(
            this.x - barWidth / 2,
            barY,
            barWidth * healthPercentage,
            barHeight
          );
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.weapon.angle += this.weapon.rotationSpeed;
          if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
            this.vx *= -1;
            this.x = Math.max(
              this.radius,
              Math.min(this.x, canvas.width - this.radius)
            );
          }
          if (
            this.y - this.radius < 0 ||
            this.y + this.radius > canvas.height
          ) {
            this.vy *= -1;
            this.y = Math.max(
              this.radius,
              Math.min(this.y, canvas.height - this.radius)
            );
          }
        }

        takeDamage(amount, hitX, hitY) {
          this.health = Math.max(0, this.health - amount);
          createHitParticles(hitX, hitY, this.color);
        }
      }

      // --- Particle Class ---
      class Particle {
        constructor(x, y, rgbColor) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 4;
          this.vy = (Math.random() - 0.5) * 4;
          this.radius = Math.random() * 3 + 1;
          this.color = rgbColor;
          this.life = 50;
        }
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color
            .replace(')', `, ${this.life / 50})`)
            .replace('rgb', 'rgba');
          ctx.fill();
          ctx.closePath();
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.life--;
        }
      }

      // --- Simulation Logic ---
      function handlePhysicsCollisions() {
        const [c1, c2] = creatures;
        const dx = c2.x - c1.x;
        const dy = c2.y - c1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < c1.radius + c2.radius) {
          const normalX = dx / distance;
          const normalY = dy / distance;
          const p =
            (2 *
              (c1.vx * normalX +
                c1.vy * normalY -
                c2.vx * normalX -
                c2.vy * normalY)) /
            (c1.mass + c2.mass);
          c1.vx -= p * c2.mass * normalX;
          c1.vy -= p * c2.mass * normalY;
          c2.vx += p * c1.mass * normalX;
          c2.vy += p * c1.mass * normalY;
          const overlap = c1.radius + c2.radius - distance;
          c1.x -= overlap * normalX * (c2.mass / (c1.mass + c2.mass));
          c1.y -= overlap * normalY * (c2.mass / (c1.mass + c2.mass));
          c2.x += overlap * normalX * (c1.mass / (c1.mass + c2.mass));
          c2.y += overlap * normalY * (c1.mass / (c1.mass + c2.mass));
        }
      }

      function handleWeaponHits() {
        const now = Date.now();
        checkLineCircleCollision(creatures[0], creatures[1], now);
        checkLineCircleCollision(creatures[1], creatures[0], now);
      }

      function checkLineCircleCollision(attacker, defender, now) {
        if (now - defender.lastHitTime < 200) return;
        const weaponStartX = attacker.x;
        const weaponStartY = attacker.y;
        const weaponEndX =
          attacker.x + Math.cos(attacker.weapon.angle) * attacker.weapon.length;
        const weaponEndY =
          attacker.y + Math.sin(attacker.weapon.angle) * attacker.weapon.length;
        const dx = weaponEndX - weaponStartX;
        const dy = weaponEndY - weaponStartY;
        const a = dx * dx + dy * dy;
        const b =
          2 *
          (dx * (weaponStartX - defender.x) + dy * (weaponStartY - defender.y));
        const c =
          (weaponStartX - defender.x) ** 2 +
          (weaponStartY - defender.y) ** 2 -
          defender.radius ** 2;
        const discriminant = b * b - 4 * a * c;
        if (discriminant >= 0) {
          const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
          const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
          if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
            const hitT = t1 >= 0 && t1 <= 1 ? t1 : t2;
            const hitX = weaponStartX + hitT * dx;
            const hitY = weaponStartY + hitT * dy;
            defender.takeDamage(attacker.damage, hitX, hitY);
            defender.lastHitTime = now;
          }
        }
      }

      function createHitParticles(x, y, color) {
        const rgbColor = (ctx.fillStyle = color);
        for (let i = 0; i < 15; i++) {
          particles.push(new Particle(x, y, rgbColor));
        }
      }

      function updateUI() {
        const [c1, c2] = creatures;
        guardianStatsEl.innerHTML = `DMG: ${c1.damage} | SPD: ${
          c1.speed
        } | ATK SPD: ${(c1.weapon.rotationSpeed * 100).toFixed(1)}`;
        strikerStatsEl.innerHTML = `DMG: ${c2.damage} | SPD: ${
          c2.speed
        } | ATK SPD: ${(c2.weapon.rotationSpeed * 100).toFixed(1)}`;
      }

      function checkWinner() {
        const [c1, c2] = creatures;
        if (c1.health <= 0 || c2.health <= 0) {
          isRunning = false;
          cancelAnimationFrame(animationFrameId);
          const winner = c1.health > 0 ? c1 : c2;
          winnerText.textContent = `${winner.name} Wins!`;
          winnerText.style.color = winner.color;
          winnerOverlay.classList.remove('hidden');
          setTimeout(() => (winnerOverlay.style.opacity = 1), 10);
          startResetBtn.textContent = 'Reset Simulation';
        }
      }

      function redrawStatic() {
        if (isRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
        creatures.forEach((c) => c.draw());
      }

      function gameLoop() {
        if (!isRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
        particles.forEach((p, index) => {
          p.update();
          p.draw();
          if (p.life <= 0) particles.splice(index, 1);
        });
        creatures.forEach((creature) => {
          creature.update();
          creature.draw();
        });
        handlePhysicsCollisions();
        handleWeaponHits();
        checkWinner();
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      function setupCanvas() {
        const container = canvas.parentElement;
        const size = Math.min(container.clientWidth, 500);
        canvas.width = size;
        canvas.height = size;
      }

      async function init() {
        startResetBtn.disabled = true;
        startResetBtn.textContent = 'Loading...';
        setupCanvas();
        winnerOverlay.classList.add('hidden');
        winnerOverlay.style.opacity = 0;

        await Promise.all([
          loadImage(defaultImages.gBody, guardianBodyImg),
          loadImage(defaultImages.gWeapon, guardianWeaponImg),
          loadImage(defaultImages.sBody, strikerBodyImg),
          loadImage(defaultImages.sWeapon, strikerWeaponImg),
          loadImage(defaultImages.bg, backgroundImg),
        ]);

        creatures = [
          new Creature(
            canvas.width * 0.25,
            canvas.height / 2,
            30,
            '#22d3ee',
            'Guardian',
            200,
            1.2,
            2.5,
            { angle: 0, length: 55, rotationSpeed: 0.02, width: 10 },
            { body: guardianBodyImg, weapon: guardianWeaponImg }
          ),
          new Creature(
            canvas.width * 0.75,
            canvas.height / 2,
            20,
            '#f87171',
            'Striker',
            100,
            2.5,
            1.5,
            { angle: 0, length: 45, rotationSpeed: 0.05, width: 8 },
            { body: strikerBodyImg, weapon: strikerWeaponImg }
          ),
        ];

        particles = [];
        updateUI();
        redrawStatic();
        startResetBtn.disabled = false;
        startResetBtn.textContent = 'Start Simulation';
      }

      startResetBtn.addEventListener('click', () => {
        if (isRunning || startResetBtn.disabled) return;
        if (startResetBtn.textContent.includes('Reset')) {
          init();
          return;
        }
        isRunning = true;
        startResetBtn.textContent = 'Running...';
        gameLoop();
      });

      window.addEventListener('resize', () => {
        if (!isRunning) init();
      });

      init();
    </script>
  </body>
</html>
